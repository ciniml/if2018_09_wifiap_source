/**
 * command.hpp
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */ 

#ifndef COMMAND_HPP__
#define COMMAND_HPP__

#include <stdint.h>
#include <stdlib.h>

// コマンドの先頭を表すマーカー
static const uint8_t* SIGNATURE = reinterpret_cast<const uint8_t*>("\xfe\xca");
// ヘッダの長さ
static const size_t COMMAND_HEADER_SIZE = 4;
// 本体の最大長さ
static const size_t MAX_COMMAND_BODY_LENGTH = 255;
// ヘッダ + 本体 + チェックサム
static const size_t MAX_COMMAND_LENGTH = COMMAND_HEADER_SIZE + MAX_COMMAND_BODY_LENGTH + 1;

// コマンドを受信するクラス
class CommandReceiver {
  uint8_t buffer[MAX_COMMAND_LENGTH]; // 受信バッファ
  uint8_t checksum; // チェックサム
  size_t bytesReceived; // 受信済みバイト数
public:
  // コンストラクタ
  CommandReceiver() : checksum(0), bytesReceived(0) {}

  // 以下の3つの関数はreceive()がtrueを返した後にのみ有効
  // コマンド番号を取得する。
  uint8_t number() const { return this->buffer[2]; }
  // コマンド本体の長さを取得する。
  uint8_t length() const { return this->buffer[3]; }
  // コマンドの本体へのポインタを取得する。
  const uint8_t* body() const { return this->buffer + COMMAND_HEADER_SIZE; }

  // 受信状態をクリアする。
  void clear() { 
    this->checksum = 0;
    this->bytesReceived = 0;
  }

  // コマンドを受信する。コマンドの受信が完了したらtrueを返す。
  bool receive(WiFiClient& client) {
    while(client.available()) { // 受信データあり？
      if( this->bytesReceived < 2 ) { // Signature未受信
        // Signature分 (2バイト) 受信する。
        this->bytesReceived += client.read(this->buffer + this->bytesReceived, 2 - this->bytesReceived);
      }
      if( this->bytesReceived == 2 ) {
        if( this->buffer[0] != SIGNATURE[0] || this->buffer[1] != SIGNATURE[1] ) {
          // Signatureが一致しない。無効なヘッダ。
          this->clear();
          continue;
        }
      }
      if( this->bytesReceived < 4 ) { // ヘッダ未受信
        this->bytesReceived += client.read(this->buffer + this->bytesReceived, 4 - this->bytesReceived);
      }
      // コマンド本体を受信する。
      if( this->bytesReceived >= COMMAND_HEADER_SIZE ) {
        // あと何バイト受信するのかを計算
        size_t bytesToReceive = this->length() + 1 - (this->bytesReceived - COMMAND_HEADER_SIZE);
        // データ受信
        size_t received = client.read(this->buffer + this->bytesReceived, bytesToReceive);
        // コマンド本体のチェックサムを計算
        for(size_t i = this->bytesReceived; i < this->bytesReceived + received; ++i) {
          this->checksum += this->buffer[i];
        }
        // 受信済みバイト数を加算
        this->bytesReceived += received;
#ifdef COMMAND_DEBUG
        Serial.print(this->bytesReceived);
        Serial.print(" ");
        Serial.print(bytesToReceive);
        Serial.print(" ");
        Serial.print(received);
        Serial.println();
#endif
        if( received == bytesToReceive ) {  // コマンド本体+チェックサムの受信完了
          if( this->checksum == 0xff ) {  // チェックサム含めてコマンド本体を加算すると0xffになるはず
            this->clear();
            return true;  // 有効なコマンドを受信した。
          }
          else {
            // チェックサムエラー。クリアする。
            Serial.println("Checksum error");
            this->clear();
          }
        }
      }
    }
    return false;
  }
};

// コマンドを送信するクラス
class CommandTransmitter {
  uint8_t buffer[MAX_COMMAND_LENGTH];
  size_t  bytesRemaining;       // 残り送信バイト数 
  const uint8_t* transferPtr;   // 次に転送するデータへのポインタ
public:
  CommandTransmitter() : bytesRemaining(0), transferPtr(nullptr) {}

  // 送信情報をクリア
  void clear() { this->bytesRemaining = 0; }
  // 送信処理の途中？
  bool transmitting() const { return this->bytesRemaining > 0; }
  // 送信するコマンドをセット
  // number: コマンド番号
  // body  : コマンドの本体データへのポインタ
  // length: コマンド本体データの長さ
  void set(uint8_t number, const uint8_t* body, uint8_t length ) {
    uint8_t checksum = 0;
    this->buffer[0] = SIGNATURE[0]; // ヘッダを設定
    this->buffer[1] = SIGNATURE[1]; // 
    this->buffer[2] = number;       // 
    this->buffer[3] = length;       // /
    // コマンドの本体をバッファにコピーしつつ、チェックサムを計算
    uint8_t* p = this->buffer + COMMAND_HEADER_SIZE;
    for(uint8_t i = 0; i < length; ++i, ++p, ++body) {
      *p = *body;
      checksum += *body;
    }
    *p = ~checksum; // 末尾にチェックサムを付加 (1の補数のチェックサム)
    // 送信する長さ
    this->bytesRemaining = length + COMMAND_HEADER_SIZE + 1;
    this->transferPtr = this->buffer;
  }
  // 送信処理をする。
  // client: データを送信するWiFiClient
  // return: 送信処理が完了したらtrue
  bool transmit(WiFiClient& client) {
    while(this->bytesRemaining > 0 && client.connected()) { // 送信データが残っている？
      // データを送信
      size_t bytesTransmit = client.write(this->transferPtr, this->bytesRemaining);
      if( bytesTransmit == 0 ) { // 全く送信できなかったので中断する。
        break;
      }
      this->bytesRemaining -= bytesTransmit;
      this->transferPtr += bytesTransmit;
    }
    // 送信データが残っていなければ送信完了
    return this->bytesRemaining == 0;
  }
};

#endif //COMMAND_HPP__
